import astropy.io.fits as fits
import numpy as np
import matplotlib.pyplot as plt
import os
from scipy import stats as sp
from datetime import datetime

from astropy.visualization import ImageNormalize, AsinhStretch

# Wavelengths
HALPHA_WAVELENGTH = 656.3 #nm
NII_LOWER_WAVELENGTH = 654.8 #nm
NII_UPPER_WAVELENGTH = 658.3 #nm

# Line Width Constants
HA_WIDTH = 2
LINE_WIDTH = 2
EDGE_WIDTH = 2

SIZE = 20

'''
No Datacubes needed
----------------------
'''

def wavenumber(wavelength):
    '''Given wavelength in nm, will return wavenumber in 1/cm

    Parameters: 
        wavelength in nm, float

    Returns: 
        wavenumber in 1/cm, float
    '''
    return (1e7)/wavelength

def wavelength(wavenumber):
    '''Given wavenumber in 1/cm, will return wavelength in nm

    Parameters: 
        wavenumber in 1/cm, float

    Returns: 
        wavelength in nm, float
    '''
    return (1e7)/wavenumber

def calculate_wavelength(redshift):
    '''Takes in a redshift and returns wavelength of Ha and NII lines.

    Parameters: 
        redshift (float) ~0.23

    Returns: 
        Ha, NII lower, NII upper (float)
    '''

    ha_shifted = HALPHA_WAVELENGTH * (1 + redshift)
    nIIL_shifted = NII_LOWER_WAVELENGTH * (1 + redshift)
    nIIU_shifted = NII_UPPER_WAVELENGTH * (1 + redshift)

    return ha_shifted, nIIL_shifted, nIIU_shifted

def mode_of_wonky_array(wonky_array):
    ''' Takes in a 3 dimensional array and returns a 2 dimensional array where each entry is the mode of the 3rd axis of the input array

    Parameters:
        wonky_array: (3D array of floats)
    Returns:
        values: (2D array of floats)
    '''

    values = np.zeros((len(wonky_array[0]),len(wonky_array[0][0])))

    for i in range(len(wonky_array[0])):
        for j in range(len(wonky_array[0][0])):
            modeList = []
            for channel in wonky_array:
                if channel[i][j] != 0 and not np.isnan(channel[i][j]):
                    modeList.append(channel[i][j])
            entry = sp.mode(modeList)
            values[i][j] = entry
    
    return values
    

'''
Image Generator
---------------
'''
class ELG_Drawer:

    def __init__(self, name, cube_path, elg_list_path="None", segm="None"):
        '''Class for creating images of ELGs from .fits files and stacking those images

        Parameters:
            name: (String) name of the object
            cube_path: (String) path to the .fits datacube

            elg_list_path: (String) path to the elg list generated by Find_emission_candidate. Optional, defaults to "None"
            segm: (String) path to the segm datacube. Effectively - the datacube with cutouts for each ELG. Defaults to "None"
        '''
        self.name = name

        self.elg_list_path = elg_list_path
        if(self.elg_list_path == "None"):
            print("WARNING: No elg list path provided, this may result in failures")

        hdul = fits.open(cube_path, mode='readonly', memmap=False)
        self.header = hdul[0].header
        self.data = hdul[0].data
        hdul.close()

        # Set the segm path and open it. I'm allowing users to not have a segm, so it will simply not load one in if none is given
        self.segmh = ""
        self.segm = segm
        try:
            hdul = fits.open(segm, mode='readonly', memmap=False)
            self.segmh = hdul[0].header
            self.segm = hdul[0].data
        except:
            print("WARNING: No segm path provided, this may result in failures")   
        
        self.outPath = "./output/" + name
        
        try:
            os.mkdir("./output")
        except:
            print("/output already created. current output folder will be used")

        try:
            os.mkdir("./output/{}".format(name))
            os.mkdir("./output/{}/pic".format(name))
            os.mkdir("./output/{}/fits".format(name))
        except:
            print("Directory ./{} already exists. Exisitng directory will be used".format(name))

        time = datetime.now()
        timestamp = time.strftime("%d-%b-%Y (%H:%M:%S.%f)")

        self.textPath = "./output/" + name + "/log.txt"
        f = open(self.textPath, "w")
        f.write("Object: {}\nCreated: {}\nPath: {}\nelg_list: {}\nsegm: {}\n".format(self.name, timestamp, cube_path, elg_list_path, segm))
        f.close()
        
    def write_file(self, message):
        '''Writes to the log file a given message

        Parameters:
            message: (String) message to write
        '''

        outFile = open(self.textPath, "a")
        outFile.write(message + "\n")
        outFile.close()

    def change_outPath(self, outPath):
        '''Changes the outPath for the datacube

        Parameters:
        outPath: (String) The name of the folder to be created. Doesn't have to include the path to the current directory
        '''
        self.outPath = "./" + outPath
        
        try:
            os.mkdir("./{}".format(outPath))
            os.mkdir("./{}/pic".format(outPath))
            os.mkdir("./{}/fits".format(outPath))
        except:
            print("Directory ./{} already exists. Exisitng directory will be used".format(outPath))
        
        self.write_file("outPath changed: {}".format(self.outPath))

    def get_max_wavenumber(self):
        '''Likely useless function that determines the upper boundary of the datacube in wavenumbers
        
        Returns:
            wavenumber: (float) maximum wavenumber in 1/cm
        '''

        min_wavenumber = self.header['CRVAL3']
        wavenumber_step = self.header['CDELT3']
        step_count = self.header['NAXIS3']

        max_wavenumber = min_wavenumber+(step_count-1)*wavenumber_step

        return max_wavenumber

    def get_wavenumber_array(self):
        '''Returns an array which contains the wavenumber for each channel
        
        Returns:
            wavn_array: (float) array of wavenumbers
        '''

        min_wavenumber = self.header['CRVAL3']
        max_wavenumber = self.get_max_wavenumber()
        wavenumber_step = self.header['CDELT3']
        
        wavn_array = np.arange(min_wavenumber, max_wavenumber, wavenumber_step)

        # ???
        wavn_array = np.flip(wavn_array)
        return wavn_array

    def get_channel(self, wavenumber):
        '''Determines which channel a given measured wavenumber emission line lies

        Parameters: 
            wavenumber: (float) wavenumber in 1/cm 
        
        Returns: 
            channel: (int) nearest channel to the given wavenumber
        '''

        wavenumber_array = self.get_wavenumber_array()

        channel = np.argmin(np.abs(wavenumber - wavenumber_array))

        return channel

    def continuum_range(self, redshift):
        '''Determins the range in which the continuum of the stellar portion of the galaxy is measured

            Takes in a redshift of a Galaxy, and considering line widths and edge of the detection range it determines the range of the continuum

            The continuum is defined as being (from Qing's paper):
                -2 nm from the edge of measurement (EDGE_WIDTH)
                -1.5 * (1 + z) nm away from NII lines (NII_WIDTH)

        Parameters:
            redshift: (float) redshift of galaxy ~0.23
        
        Returns:
            range: (array of floats) wavenumbers that represent the channels of the Emission
        '''

        # Determine expected wavenumbers of redshifted lines
        _, nl_wl, nu_wl = calculate_wavelength(redshift) 

        # Determine boundaries of nII lines
        # We do this by taking lowest nL and highest nU border
        nII_boundary = (wavenumber(nl_wl - (LINE_WIDTH * (1 + redshift))), wavenumber(nu_wl + (LINE_WIDTH * (1 + redshift))))

        # Determine boundary of the measurement itself in wavenumbers
        wavn_array = self.get_wavenumber_array()

        m_boundary = (wavenumber(wavelength(np.min(wavn_array)) - EDGE_WIDTH), wavenumber(wavelength(np.max(wavn_array)) + EDGE_WIDTH))

        # What we have now computed is the range that the continuum does not cover
        # We will simply compare each channel to each range to see whether it falls in it or not
        # Surely this could be more efficient
        continuum_wavn_array = []
        for i in range(len(wavn_array)):
            # First, check if it is within range of measurement boundaries
            if wavn_array[i] > m_boundary[0] and wavn_array[i] < m_boundary[1]:
                # Next, check if it is not in range of the lines
                if wavn_array[i] > nII_boundary[0] or wavn_array[i] < nII_boundary[1]: # ha
                            continuum_wavn_array.append(wavn_array[i]) 
        
        return continuum_wavn_array

    def emission_range(self, redshift):
        '''Determins the range in which the emission line of the galaxy is measured

            The width of the emission line is defined as (from Qing's paper):
                -0.5 * (1 + z) nm from emission line. (HA_WIDTH)

        Parameters:
            redshift: (float) redshift of galaxy ~0.23
        
        Returns:
            range: (array of floats) wavenumbers that represent the channels of the Emission
        '''

        ha_wl, _, _ = calculate_wavelength(redshift) 
        width = HA_WIDTH * (1 + redshift)

        ha_boundary = (wavenumber(ha_wl - width), wavenumber(ha_wl + width))
        wavn_array = self.get_wavenumber_array()

        emission_wavn_array = []
        for i in range(len(wavn_array)):
            if wavn_array[i] < ha_boundary[0] and wavn_array[i] > ha_boundary[1]:
                emission_wavn_array.append((wavn_array[i]))


        return emission_wavn_array

    def sum_arrays(self, array, algorithm="mean", stack=False):
        '''Puts a 3d array into a 2d array by a multitude of means. Used in create_image and create_stack

        Parameters:
            array: (3d array of floats) input array

            algorithm: (String) the algorithm to use to create the images. default='mean'. Options: 'mean', 'sum', 'median', 'mode'
            stack: (Boolean) determines if it is a stack or an image
        
        Returns:
            output: (2d array of floats)
        '''
        output = []

        if algorithm == 'mean':
            output = np.nanmean(array, axis=0)
        elif algorithm == 'sum':
            output = np.nansum(array, axis=0)
        elif algorithm == 'median':
            if stack:
                output = self.image_of_medians(array)
            else:
                output = np.nanmedian(array, axis=0)
        elif algorithm == 'mode':
            output = mode_of_wonky_array(array)
        else:
            raise ValueError("Invalid algorithm specified. The choices are: 'mean', 'sum', 'median', 'mode'")     
        
        return output


    def sum_channels(self, wavn_array, xLoc, yLoc, algorithm="mean", name=""):
        ''' Adds all channels corresponding to a certain wavenumber array together to create images

        Parameters:
            wavn_array: (array) wavenumbers each corresponding to a channel, that will be included in the image
            xLoc: (float) x location that we want to get the measurements from
            yLoc: (float) y location that we want to get the measurements from

            algorithm: (String) the algorithm to use to create the images. default='mean'. Options: 'mean', 'sum', 'median', 'mode'
            name: (String) used only if a segm fits file is used for better images

        Returns:
            output: (float) Represents the average of all measurements, to be used in the image
        '''

        measurements = []
        for wavn in wavn_array:
            channel = self.get_channel(wavn)
            value = self.data[channel, yLoc, xLoc]
            if not np.isnan(value):
                if name != "":
                    if self.segm[yLoc, xLoc] == name or self.segm[yLoc, xLoc] == 0:
                        measurements.append(value)
                    else:
                        measurements.append(0)
                else:
                    measurements.append(value)
        
        output = self.sum_arrays(measurements, algorithm=algorithm)
        
        return output
    
    def create_image(self, wavn_image, xCentroid, yCentroid, algorithm="mean", name="", emission=False, redshift=0):
        '''Generates an image around a certain point

        Parameters:
            wavn_array: (array of floats) each wavenumber represents a channel in the cube that will be summed for the image
            xCentroid: (float) x location of the center of the image
            yCentroid: (float) y location of the center of the image


            algorithm: (String) the algorithm to use to create the images. default='mean'. Options: 'mean', 'sum', 'median', 'mode'
            name: (String) used only if a segm fits file is used for better images
            emission: (Boolean) defaults to False: determines if continuum needs to be subtracted
            redshift: (float) defaults to 0. This one is goofy. You NEED to provide a redshift if emission=True

        Returns:
            image: (2D array of floats) each point in the array represents a pixel in the image
        '''

        xCentroid = int(xCentroid)
        yCentroid = int(yCentroid)
        xValues = np.arange(xCentroid - SIZE, xCentroid + SIZE, 1)
        yValues = np.arange(yCentroid - SIZE, yCentroid + SIZE, 1)
        image = np.zeros((2 * SIZE, 2 * SIZE))

        for i, xLoc in enumerate(xValues):
            for j, yLoc in enumerate(yValues):
                image[i][j] = self.sum_channels(wavn_image, xLoc, yLoc, algorithm, name=name)
        
        if emission:
            # subtracts the continuum
            image = image - self.create_image(self.continuum_range(redshift), xCentroid, yCentroid, algorithm="median", name=name, emission=False)

        return image
    
    def import_image(self, path):
        '''Loads in a .fits cutout as a 2D array

        Parameters:
            path: (String) path to file
        
        Returns:
            data: (3D array of floats) 2D array that represents an image
        '''

        hdul = fits.open(path, mode='readonly', memmap=False)
        data = hdul[0].data
        hdul.close()

        return data

    def load_images(self, path=None):
        '''Loads in all .fits cutouts from the output directory into a 3D array
        
        Returns:
            images: (3D array of floats) 3D array of images

            path: (String) (Optional) Defaults to None which gives the objects output folder. Can be used to pull .fits files from anywhere
        '''
        # to determine if the elg is faint enough to be stacked
        elg_list_file = open(self.elg_list_path, mode="r")
        elg_list = elg_list_file.readlines()
        elg_list_file.close()

        if path is None:
            path = self.outPath + "/fits"

        images = np.zeros((len(os.listdir(path)), 2 * SIZE, 2 * SIZE))

        for i, filename in enumerate(os.listdir(path)):
            still_indexed = True # the still_indexed will be the catch in case extra files are in the folder. otherwise this would crash
            try:
                elg = elg_list[i + 1] # because we need to exclude the header line
                elg_name = elg.split(" ")[0]
            except:
                still_indexed = False
                print("You included extra images in your outfolder. Be careful")

            if still_indexed: 
                if self.is_below_average_flux(elg_name): # only include the faint ELGs
                    image = self.import_image(os.path.join(path, filename))
                    try:
                        images[i] = image
                    except:
                        i -= 1 # it was a different kind of file. Skip to the next without skipping indeces

        return images
        
    def append_median_flux(self):
        '''Loads in an elg list from Qing's code and adds the median flux for each elg. Only needs to be run if the median flux is not written into the elg list file

        Parameters:
            list_path: (String) path to the elg list
        '''

        elg_list = open(self.elg_list_path, mode="r")
        lines = elg_list.readlines()
        elg_list.close()

        printOut = lines[0][:-1] + " med_flux\n"

        for i in range(1, len(lines)):
            line = lines[i].split(" ")
            xCentroid = float(line[1])
            yCentroid = float(line[2])
            printOut = printOut + lines[i][:-1] + " {:.3f}\n".format(self.determine_median_flux(int(xCentroid), int(yCentroid)))
        
        elg_list = open(self.elg_list_path, mode="w")
        elg_list.write(printOut)
        elg_list.close()

    def determine_median_flux(self, xLoc, yLoc, data=None):
        '''Determines the median flux for a given x and y location

        Parameters:
            xCentroid: (int) x location
            yCentroid: (int) y location

            data: (3D array of floats) (Optional) Defaults to None which uses self.data. Can be used to provide alternative cube
        '''

        cube = self.data
        if data is not None:
            cube = data
        yVals = []

        for i in range(len(cube)):
            value = cube[i, yLoc, xLoc]
            if value != 0 and not np.isnan(value):
                yVals.append(cube[i, yLoc, xLoc])

        return np.median(yVals)

    def image_of_medians(self, images):
        ''' Used for cube stacking to create a single two dimensional array of the medians of the 0 axis of a 3 dimensional array
        '''
        image = np.zeros((2*SIZE, 2*SIZE))

        for i in range(2*SIZE):
            for j in range(2*SIZE):
                image[i, j] = self.determine_median_flux(i, j, data=images)
        
        return image

    def is_below_average_flux(self, label, index=9):
        '''Is used for stacking. Will determine if a given ELG is faint enough to be included in the stack. By this method, the bottom half (less than the median) of ELGS will be used
        
        Parameters:
            label: (String) the number of the ELG as provided by the elg_list

            index: (int) (optional) defaults to 9. Depends on which index in each line the median flux is written
        
        Returns:
            (boolean) whether or not the elg should be included in stacking
        '''

        elg_list = open(self.elg_list_path, mode="r")
        lines = elg_list.readlines()
        elg_list.close()

        cutoff = self.median_flux_elg_list(index=index)

        for line in lines:
            line = line.split(" ")
            if label == line[0]:
                if float(line[index]) < cutoff:
                    return True
                else:
                    return False
        return False

    def median_flux_elg_list(self, index=9):
        '''Determines the median of the median fluxes in the elg list. Used as part of the is_below_average_flux function

        Parameters:
            index: (int) (optional) defaults to 9. Depends on which index in each line the median flux is written
        
        Returns:
            (float) median of the flux medians
        '''

        elg_list = open(self.elg_list_path, mode="r")
        elg_list.readline()
        lines = elg_list.readlines()
        elg_list.close()

        values = []

        for line in lines:
            line = line.split(" ")
            values.append(float(line[index]))
        
        return np.median(values)

    def create_stack(self, algorithm="mean", path=None):
        '''Stacks a series of images created by the create_image function

        Parameters:
            algorithm: (String) (Optional) The algorithm to use to create the images. default='mean'. Options: 'mean', 'sum', 'median', 'mode'
            path: (String) (Optional) Defaults to None, which gives the objects output folder. Can be used to pull .fits files from anywhere

        Returns:
            image: (2D array of floats) each point in the array represents a pixel in the image
        
        Exceptions:
            Will complain if you don't provide a valid algorithm
        '''

        images = self.load_images(path=path)  

        output = self.sum_arrays(images, algorithm=algorithm, stack=True)

        return output

    def save_pdf(self, name, image, xLoc=SIZE, yLoc=SIZE, stack=False):
        '''creates a pdf using matplotlib's imshow() function

        Parameters:
            name: (string) name for file to be saved as
            image: (array of floats) 2 dimensional numpy array each containing a float representing colour make use of self.create_image

            stack: (boolean) whether it is a stack or not. This gives it a special directory. defaults to False

        Returns:
            None. The pdf will be automatically saved.
        '''

        picsPath = self.outPath
        fitsPath = self.outPath
        if stack == False:
            picsPath += "/pic"
            fitsPath += "/fits"

        norm = ImageNormalize(vmin=np.min(image), vmax=np.max(image), stretch=AsinhStretch(a=0.1))

        plt.rcParams["figure.figsize"] = [7.00, 3.50]
        plt.rcParams["figure.autolayout"] = True

        ax = plt.gca()
        ax.imshow(image, origin="lower", norm=norm)

        ax.set_title(name)

        if stack == False:
            xLocs, xLabels = plt.xticks()
            yLocs, yLabels = plt.yticks()
            xLabels = np.linspace(xLoc - SIZE, xLoc + SIZE, num=len(xLocs), dtype=int)
            yLabels = np.linspace(yLoc - SIZE, yLoc + SIZE, num=len(yLocs), dtype=int)

            ax.set_xticklabels(xLabels)
            ax.set_yticklabels(yLabels)

            ax.set_xlabel("x (pix)")
            ax.set_ylabel("y (pix)")
        else:
            plt.axis('off')

        plt.savefig("{}/{}.png".format(picsPath, name))
        fits.writeto("{}/{}".format(fitsPath, name), image, overwrite=True)
    

# For fun and testing functions. Can be ignored            
    def compare(self, image_1, image_2):
        '''compares two images and returns an image with either 0 or 1 based on which image has the higher value there

        Parameters:
            image_1, image_2: (2D array of floats) the input image arrays
        Returns:
            image: (2D array of floats) the resulting image
        '''
        image = np.zeros((len(image_1[0]), len(image_1[0])))

        for i in range(len(image_1[0])):
            for j in range(len(image_1[0])):
                if image_1[i][j] < image_2[i][j]:
                    image[i][j] = 1
        
        return image

    def graph(self, xCentroid, yCentroid):
        '''
        '''

        size = 0
        yVals = []

        for i in range(len(self.data)):
            yVals.append(self.data[i, yCentroid, xCentroid])
            size = i

        xVals = np.linspace(1, len(self.data), num=size + 1)

        plt.scatter(xVals, yVals - np.median(yVals))
        plt.axhline(np.median(yVals))
        plt.show()
    
    def graph_wavn(self, name, continuum, emission, xCentroid, yCentroid):
        '''
        '''

        yContinuum = []
        yEmission = []
        yTotal = []

        for wavn in continuum:
            channel = self.get_channel(wavn)
            yContinuum.append(self.data[channel, yCentroid, xCentroid])

        for wavn in emission:
            channel = self.get_channel(wavn)
            yEmission.append(self.data[channel, yCentroid, xCentroid])

        total = self.get_wavenumber_array()

        for wavn in total:
            channel = self.get_channel(wavn)
            yTotal.append(self.data[channel, yCentroid, xCentroid])

        plt.plot(total, yTotal, "--")
        plt.plot(emission, yEmission, color="red")
        plt.plot(continuum, yContinuum, color="blue")
        plt.title(name)
        plt.show()

