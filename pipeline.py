import astropy.io.fits as fits
import numpy as np
import matplotlib.pyplot as plt
import os
from scipy import stats as sp
from datetime import datetime

from astropy.visualization import ImageNormalize, AsinhStretch
from matplotlib.patches import Circle
from astropy.cosmology import FlatLambdaCDM

### CONSTANTS ###
### --------- ###

# Wavelengths
HALPHA_WAVELENGTH = 656.3 #nm
NII_LOWER_WAVELENGTH = 654.8 #nm
NII_UPPER_WAVELENGTH = 658.3 #nm

# Line Width Constants
HA_WIDTH = 1
LINE_WIDTH = 2
EDGE_WIDTH = 2

SIZE = 40 # the image will be 2SIZE by 2SIZE
MAX_ELG_SIZE = 20 # Maximum ELG size for brightness calculations (overestimation doesn't make it less correct, only more expensive)

# Aperture size and 'closeness' used for curves of growth
APERTURE_SIZE = SIZE#int(SIZE * (3/4))
CURVE_CLOSENESS = 0.05
FULL_LIGHT_CUTOFF = 0.10 # Used to determine whether the max value should be used for full light

# Inner and outer radius used to determine sky value
INNER_RADIUS = int(SIZE * (3/4))
OUTER_RADIUS = int(SIZE * (9/10))

RESOLUTION = 0.322 #arcsec/pix

### NO DATACUBES NEEDED ###
### ------------------- ###

def wavenumber(wavelength):
    '''Given wavelength in nm, will return wavenumber in 1/cm

    Parameters: 
        wavelength in nm, float

    Returns: 
        wavenumber in 1/cm, float
    '''
    return (1e7)/wavelength

def wavelength(wavenumber):
    '''Given wavenumber in 1/cm, will return wavelength in nm

    Parameters: 
        wavenumber in 1/cm, float

    Returns: 
        wavelength in nm, float
    '''
    return (1e7)/wavenumber

def calculate_wavelength(redshift):
    '''Takes in a redshift and returns wavelength of Ha and NII lines.

    Parameters: 
        redshift (float) ~0.23

    Returns: 
        Ha, NII lower, NII upper (float)
    '''

    ha_shifted = HALPHA_WAVELENGTH * (1 + redshift)
    nIIL_shifted = NII_LOWER_WAVELENGTH * (1 + redshift)
    nIIU_shifted = NII_UPPER_WAVELENGTH * (1 + redshift)

    return ha_shifted, nIIL_shifted, nIIU_shifted

def mode_of_wonky_array(wonky_array):
    ''' Takes in a 3 dimensional array and returns a 2 dimensional array where each entry is the mode of the 3rd axis of the input array

    Parameters:
        wonky_array: (3D array of floats)

    Returns:
        values: (2D array of floats)
    '''

    values = np.zeros((len(wonky_array[0]),len(wonky_array[0][0])))

    for i in range(len(wonky_array[0])):
        for j in range(len(wonky_array[0][0])):
            modeList = []
            for channel in wonky_array:
                if channel[i][j] != 0 and not np.isnan(channel[i][j]):
                    modeList.append(channel[i][j])
            entry = sp.mode(modeList)
            values[i][j] = entry
    
    return values

def import_fits(path):
    '''Loads in a .fits cutout as a 2D array

    Parameters:
        path: (String) path to file
    
    Returns:
        data: (3D array of floats) 2D array that represents an image
    '''

    hdul = fits.open(path, mode='readonly', memmap=False)
    data = hdul[0].data
    hdul.close()

    return data

def convert_elg_list(name, path, elg_name=0, xCentroid=1, yCentroid=2, redshift=7, med_flux=8):
    '''converts Qing's elg list to the type I prefer to use. The type I prefer to use goes as follows:
    In each row: index 0: ELG name, index 1: xCentroid, index2: yCentroid, index3: redshift, index4: median flux at centroid
    '''

    end_file = open("{}.txt".format(name), 'w')
    infile = np.loadtxt(path, skiprows=1)

    end_file.write("name xCentroid yCentroid redshift med_flux")
    for elg in infile:
        end_file.write("{} {} {} {} {}".format(elg[elg_name], elg[xCentroid], elg[yCentroid], elg[redshift], elg[med_flux]))

'''
Image Generator
---------------
'''
class ELG_Drawer:

    def __init__(self, name, cube_path, elg_list_path="None", segm="None", redshift=0, r200=0, z_column=7, med_flux_col=8):
        '''Class for creating images of ELGs from .fits files and stacking those images

        Parameters:
            name: (String) name of the object
            cube_path: (String) path to the .fits datacube

            elg_list_path: (String) path to the elg list generated by Find_emission_candidate. Optional, defaults to "None"
            segm: (String) path to the segm datacube. Effectively - the datacube with cutouts for each ELG. Defaults to "None"
            redshift: (float) redshift to the galaxy cluster. Defaults to 0
            r200: (float) r_200 distance (in Mpc)
            z_column: (int) the index of the column that contains the redshifts in the elg_list. Defaults to 7
            med_flux_col: (int) index of the column that contains the median fluxes in the elg_list. Defaults to 8
        '''
        self.name = name
        self.redshift = redshift

        self.z_column = z_column
        self.med_flux_column = med_flux_col

        self.dist_array = self.generate_distance_array(2*SIZE)

        self.elg_list_path = elg_list_path
        if(self.elg_list_path == "None"):
            print("WARNING: No elg list path provided, this may result in failures")

        hdul = fits.open(cube_path, mode='readonly', memmap=False)
        self.header = hdul[0].header
        self.data = hdul[0].data
        hdul.close()

        # Set the segm path and open it. I'm allowing users to not have a segm, so it will simply not load one in if none is given
        self.segmh = ""
        self.segm = segm
        try:
            hdul = fits.open(segm, mode='readonly', memmap=False)
            self.segmh = hdul[0].header
            self.segm = hdul[0].data
        except:
            print("WARNING: No segm path provided, this may result in failures")   
        
        self.outPath = "./output/" + self.name
        self.outfolders = []
        
        try:
            os.mkdir("./output")
        except:
            print("/output already created. current output folder will be used")

        try:
            os.mkdir(self.outPath)
        except:
            print("Directory ./{} already exists. Exisitng directory will be used".format(name))

        try:
            os.mkdir("{}/pic".format(self.outPath))
            os.mkdir("{}/fits".format(self.outPath))
        except:
            print("Reusing a couple directories")

        time = datetime.now()
        timestamp = time.strftime("%d-%b-%Y (%H:%M:%S.%f)")

        self.textPath = "./output/" + name + "/log.txt"
        f = open(self.textPath, "w")
        f.write("Object: {}\nCreated: {}\nPath: {}\nelg_list: {}\nsegm: {}\nredshift: {}\n".format(self.name, timestamp, cube_path, elg_list_path, segm, self.redshift))
        f.close()

        self.r_200 = self.determine_length_kpc(r200)

    def write_file(self, message):
        '''Writes to the log file a given message

        Parameters:
            message: (String) message to write
        '''

        outFile = open(self.textPath, "a")
        outFile.write(message + "\n")
        outFile.close()

    def change_outPath(self, outPath):
        '''Changes the outPath for the datacube

        Parameters:
        outPath: (String) The name of the folder to be created from the current working directory
        '''
        self.outPath = "./" + outPath
        
        try:
            os.mkdir("./{}".format(outPath))
            os.mkdir("./{}/pic".format(outPath))
            os.mkdir("./{}/fits".format(outPath))
        except:
            print("Directory ./{} already exists. Exisitng directory will be used".format(outPath))
        
        self.write_file("outPath changed: {}".format(self.outPath))

### IMAGES ###
### ------ ###

    def get_max_wavenumber(self):
        '''Likely useless function that determines the upper boundary of the datacube in wavenumbers
        
        Returns:
            wavenumber: (float) maximum wavenumber in 1/cm
        '''

        min_wavenumber = self.header['CRVAL3']
        wavenumber_step = self.header['CDELT3']
        step_count = self.header['NAXIS3']

        max_wavenumber = min_wavenumber+(step_count-1)*wavenumber_step

        return max_wavenumber

    def get_wavenumber_array(self):
        '''Returns an array which contains the wavenumber for each channel
        
        Returns:
            wavn_array: (float) array of wavenumbers
        '''

        min_wavenumber = self.header['CRVAL3']
        max_wavenumber = self.get_max_wavenumber()
        wavenumber_step = self.header['CDELT3']
        
        wavn_array = np.arange(min_wavenumber, max_wavenumber, wavenumber_step)

        # ???
        wavn_array = np.flip(wavn_array)
        return wavn_array

    def get_channel(self, wavenumber):
        '''Determines which channel a given measured wavenumber emission line lies

        Parameters: 
            wavenumber: (float) wavenumber in 1/cm 
        
        Returns: 
            channel: (int) nearest channel to the given wavenumber
        '''

        wavenumber_array = self.get_wavenumber_array()

        channel = np.argmin(np.abs(wavenumber - wavenumber_array))

        return channel

    def continuum_range(self, redshift):
        '''Determins the range in which the continuum of the stellar portion of the galaxy is measured

            Takes in a redshift of a Galaxy, and considering line widths and edge of the detection range it determines the range of the continuum

            The continuum is defined as being (from Qing's paper):
                -2 nm from the edge of measurement (EDGE_WIDTH)
                -1.5 * (1 + z) nm away from NII lines (NII_WIDTH)

        Parameters:
            redshift: (float) redshift of galaxy ~0.23
        
        Returns:
            range: (array of floats) wavenumbers that represent the channels of the Emission
        '''

        # Determine expected wavenumbers of redshifted lines
        _, nl_wl, nu_wl = calculate_wavelength(redshift) 

        # Determine boundaries of nII lines
        # We do this by taking lowest nL and highest nU border
        nII_boundary = (wavenumber(nl_wl - (LINE_WIDTH * (1 + redshift))), wavenumber(nu_wl + (LINE_WIDTH * (1 + redshift))))

        # Determine boundary of the measurement itself in wavenumbers
        wavn_array = self.get_wavenumber_array()

        m_boundary = (wavenumber(wavelength(np.min(wavn_array)) - EDGE_WIDTH), wavenumber(wavelength(np.max(wavn_array)) + EDGE_WIDTH))

        # What we have now computed is the range that the continuum does not cover
        # We will simply compare each channel to each range to see whether it falls in it or not
        # Surely this could be more efficient
        continuum_wavn_array = []
        for i in range(len(wavn_array)):
            # First, check if it is within range of measurement boundaries
            if wavn_array[i] > m_boundary[0] and wavn_array[i] < m_boundary[1]:
                # Next, check if it is not in range of the lines
                if wavn_array[i] > nII_boundary[0] or wavn_array[i] < nII_boundary[1]: # ha
                            continuum_wavn_array.append(wavn_array[i]) 
        
        return continuum_wavn_array

    def emission_range(self, redshift, line_type="ha"):
        '''Determines the range in which the emission line of the galaxy is measured

            The width of the emission line is defined as (from Qing's paper):
                -0.5 * (1 + z) nm from emission line. (HA_WIDTH)

        Parameters:
            redshift: (float) redshift of galaxy ~0.23

            line_type: (Optional) (String) 'halpha', 'nIIl' and 'nIIu'. Decide which line we're interested in
        
        Returns:
            (array of floats) array of wavenumbers that represent the channels of the Emission
        '''
        wavn_array = self.get_wavenumber_array()

        emission_wavn_array = []

        ha_wl, nl_wl, nu_wl = calculate_wavelength(redshift) 

        target_wl = 0
        if line_type == "halpha":
            target_wl = ha_wl
        elif line_type == "nIIl":
            target_wl = nl_wl
        elif line_type == "nIIu":
            target_wl = nu_wl
        else:
            raise ValueError("Invalid line_type specified. The choices are: 'halpha', 'nIIl' and 'nIIu'")

        width = HA_WIDTH * (1 + redshift)
        if line_type != "ha":
            width = LINE_WIDTH * (1 + redshift)

        boundary = (wavenumber(target_wl - width), wavenumber(target_wl + width))

        for i in range(len(wavn_array)):
            if wavn_array[i] < boundary[0] and wavn_array[i] > boundary[1]:
                emission_wavn_array.append((wavn_array[i]))

        return emission_wavn_array

    def get_wavn_range(self, redshift, imtype):
        '''Runner function for emission_range and continuum_range to easily iterate through them to make other functions more streamlined

        Parameters:
            redshift: (float) redshift of galaxy ~0.23
            imtype: (String) type of wavn_range that we want: 'continuum', 'halpha', 'nIIl' and 'nIIu'

        Returns:
            (array of floats) array of wavenumbers that represent the channels of the Emission
        '''
        
        if imtype == 'continuum':
            return self.continuum_range(redshift)
        elif imtype in ['halpha', 'nIIl', 'nIIu']:
            return self.emission_range(redshift, imtype)
        else:
            raise ValueError("imtype specified was not in the working list: 'continuum', 'halpha', 'nIIl' and 'nIIu'")
    
    def sum_arrays(self, array, algorithm="mean", stack=False):
        '''Puts a 3d array into a 2d array by a multitude of algorithms. Used in create_image and create_stack

        Parameters:
            array: (3d array of floats) input array

            algorithm: (String) the algorithm to use to create the images. default='mean'. Options: 'mean', 'sum', 'median', 'mode'
            stack: (Boolean) determines if it is a stack or an image
        
        Returns:
            output: (2d array of floats)
        '''
        output = []
        if algorithm == 'mean':
            output = np.nanmean(array, axis=0)
        elif algorithm == 'sum':
            output = np.nansum(array, axis=0)
        elif algorithm == 'median':
            if stack:
                output = self.image_of_medians(array)
            else:
                output = np.nanmedian(array, axis=0)
        elif algorithm == 'mode':
            output = mode_of_wonky_array(array)
        else:
            raise ValueError("Invalid algorithm specified. The choices are: 'mean', 'sum', 'median', 'mode'")     
        
        return output

    def determine_median_flux(self, xLoc, yLoc, data=None):
        '''Determines the median flux for a given x and y location

        Parameters:
            xCentroid: (int) x location
            yCentroid: (int) y location

            data: (3D array of floats) (Optional) Defaults to None which uses self.data. Can be used to provide alternative cube
        
        Returns:
            (float)
        '''

        cube = self.data
        if data is not None:
            cube = data
        yVals = []

        for i in range(len(cube)):
            value = cube[i, xLoc, yLoc]
            if value != 0 and not np.isnan(value):
                yVals.append(cube[i, xLoc, yLoc])

        return np.median(yVals)

    def image_of_medians(self, images):
        ''' Used to create a single two dimensional array of the medians of the 0 axis of a 3 dimensional array of floats

        Parameters:
            images: (3D array of floats)
        
        Returns:
            image: (2D array of floats) each index represents the median of the values from the third dimension in the input array
        '''

        image = np.zeros((2*SIZE, 2*SIZE))

        for i in range(2*SIZE):
            for j in range(2*SIZE):
                image[i, j] = self.determine_median_flux(i, j, data=images)
        
        return image
    
    def sum_channels(self, wavn_array, xLoc, yLoc, algorithm="mean", name=""):
        ''' Adds all channels corresponding to a certain wavenumber array together to create images

        Parameters:
            wavn_array: (array) wavenumbers each corresponding to a channel, that will be included in the image
            xLoc: (float) x location that we want to get the measurements from
            yLoc: (float) y location that we want to get the measurements from

            algorithm: (String) the algorithm to use to create the images. default='mean'. Options: 'mean', 'sum', 'median', 'mode'
            name: (String) used only if a segm fits file is used for better images

        Returns:
            output: (float) Represents the average of all measurements, to be used in the image
        '''

        measurements = []
        xLoc = int(xLoc)
        yLoc = int(yLoc)

        for wavn in wavn_array:
            channel = self.get_channel(wavn)
            value = self.data[channel, yLoc, xLoc]
            if not np.isnan(value):
                if name != "":
                    if self.segm[yLoc, xLoc] == 0 or self.segm[yLoc, xLoc] == name: 
                        measurements.append(value)
                    else:
                        measurements.append(np.nan)
                else:
                    measurements.append(value)
        
        output = self.sum_arrays(measurements, algorithm=algorithm)
        
        return output
    
    def sky_value(self, image):
        '''Determines the 'sky value' of a given 2D float array. This is calculated by taking a ring near the edges of the image and averaging the pixels inside
        This method makes use of many methods created much farther down in the code as part of the curve of growth code

        Parameters:
            image: (2D array of floats) the input image
        
        Returns:
            skyVal: (float) the average value of the background in the image
        '''

        values = []

        for i in range(SIZE*2):
            for j in range(SIZE*2):
                if INNER_RADIUS < self.dist_array[i, j] and self.dist_array[i, j] < OUTER_RADIUS:
                    values.append(image[i, j])
        
        skyVal = np.nanmean(values)

        return skyVal

    def create_image(self, wavn_image, xCentroid, yCentroid, algorithm="mean", name="", remove_skyval=True, emission=False, redshift=0):
        '''Generates an image around a certain point

        Parameters:
            wavn_array: (array of floats) each wavenumber represents a channel in the cube that will be summed for the image
            xCentroid: (float) x location of the center of the image
            yCentroid: (float) y location of the center of the image


            algorithm: (String) the algorithm to use to create the images. default='mean'. Options: 'mean', 'sum', 'median', 'mode'
            name: (String) used only if a segm fits file is used for better images

            I HATE THIS vv
            emission: (Boolean) defaults to False: determines if continuum needs to be subtracted
            redshift: (float) defaults to 0. This one is goofy. You NEED to provide a redshift if emission=True
            I HATE THIS ^^

        Returns:
            image: (2D array of floats) each point in the array represents a pixel in the image
        '''

        xCentroid = int(xCentroid)
        yCentroid = int(yCentroid)
        xValues = np.arange(xCentroid - SIZE, xCentroid + SIZE, 1)
        yValues = np.arange(yCentroid - SIZE, yCentroid + SIZE, 1)
        image = np.zeros((2 * SIZE, 2 * SIZE))

        for i, xLoc in enumerate(xValues):
            for j, yLoc in enumerate(yValues):
                image[i][j] = self.sum_channels(wavn_image, xLoc, yLoc, algorithm, name=name)

        # subtract the continuum
        if emission:
            image -= self.create_image(self.continuum_range(redshift), xCentroid, yCentroid, algorithm=algorithm, name=name, emission=False, remove_skyval=False)

        # subtract the background average value
        if remove_skyval:
            image -= self.sky_value(image)
            
        return image

    def elg_brightness(self, name, xcentroid, ycentroid, image):
        """_summary_

        Args:
            name (_type_): _description_
            xcentroid (_type_): _description_
            ycentroid (_type_): _description_
            image (_type_): _description_
        """
        
        total = 0
        
        for i in range(-MAX_ELG_SIZE, MAX_ELG_SIZE):
            for j in range(-MAX_ELG_SIZE, MAX_ELG_SIZE):
                if self.segm[int(xcentroid) + i, int(ycentroid) + j] == name:
                    total += image[i, j]

        return total
    
    def elg_brightness_catalogue(self, algorithm='sum', elg_list_path=None):
        """_summary_

        Args:
            algorithm (str, optional): _description_. Defaults to 'sum'.
            elg_list_path (_type_, optional): _description_. Defaults to None.
        """
        
        # load in the elg_list
        if elg_list_path is None:
            elg_list = np.loadtxt(self.elg_list_path, skiprows=1)
        else:
            elg_list = np.loadtxt(elg_list_path, skiprows=1)

        output = ""
        
        for elg in elg_list:
            name = int(elg[0])
            print("Calculating ELG {}...".format(name))
            wavn_range = self.get_wavn_range(elg[self.z_column], "halpha")
            image = self.create_image(wavn_range, elg[1], elg[2], algorithm=algorithm, name=name, emission=True, remove_skyval=True, redshift=elg[self.z_column])
            brightness = self.elg_brightness(name, elg[1], elg[2], image)
            output = output + "{} {}".format(name, brightness) + "\n"
        
        outFile = open(self.textPath, "a")
        outFile.write(output)
        outFile.close()
        
    def generate_images(self, image_types, algorithm='sum', elg_list_path=None):
        '''A general run function for generating all the images needed for a certain analysis. 

        Parameters:
            image_types: (list of floats) list of all the image types that will be generated. The following options: 'continuum', 'halpha', 'nIIl' and 'nIIu'
            algorithm: (Optional) (String) algorithm type to use. Default is sum, there may not be other options.
            elg_list_path: (Optional) (String) path to elg_list if cube was not initialized with one
        '''
        # Set the imtypes
        acceptable_image_types = ['continuum', 'halpha', 'nIIl', 'nIIu']
        working_image_types = []
        for imtype in acceptable_image_types:
                if imtype in image_types:
                    working_image_types.append(imtype)

        # load in the elg_list
        if elg_list_path is None:
            elg_list = np.loadtxt(self.elg_list_path, skiprows=1)
        else:
            elg_list = np.loadtxt(elg_list_path, skiprows=1)

        self.write_file("Generating Images of the following types: {}.\nGenerating Images with the following algorithm: {}".format(working_image_types, algorithm))

        # create the new directories
        try:
            for imtype in working_image_types:
                os.mkdir("{}/pic/{}".format(self.outPath, imtype))
                os.mkdir("{}/fits/{}".format(self.outPath, imtype))
        except:
            print("WARNING: Something goofy happened while creating new directories, they may already exist.")
        
        for imtype in working_image_types:
            print("PRINTING {} IMAGES".format(imtype))
            for elg in elg_list:
                name = int(elg[0])
                print("Printing ELG {}...".format(name))
                wavn_range = self.get_wavn_range(elg[self.z_column], imtype)

                if imtype == 'continuum':
                    image = self.create_image(wavn_range, elg[1], elg[2], algorithm=algorithm, name=name)
                else:
                    image = self.create_image(wavn_range, elg[1], elg[2], algorithm=algorithm, name=name, emission=True, redshift=elg[self.z_column])

                self.save_pdf("{} Object {} {}".format(self.name, name, imtype), image, elg[1], elg[2], subPath=imtype)


### STACKING ###
### -------- ###

    def load_images(self, percentiles=(10, 90), path=None, use_R200=0):
        '''Loads in all .fits cutouts from the output directory into a 3D array
        
        Returns:
            images: (3D array of floats) 3D array of images

            percentiles: (tuple of floats) (Optional) determines what percentiles of brightness you want to use
            path: (String) (Optional) Defaults to None which gives the objects output folder. Can be used to pull .fits files from anywhere
        '''
        # to determine if the elg is faint enough to be stacked
        elg_list_file = open(self.elg_list_path, mode="r")
        elg_list = elg_list_file.readlines()
        elg_list_file.close()

        if path is None:
            path = self.outPath + "/fits"

        images = np.zeros((len(os.listdir(path)), 2 * SIZE, 2 * SIZE))

        count = 0

        for i, filename in enumerate(os.listdir(path)):
            still_indexed = True # the still_indexed will be the catch in case extra files are in the folder. otherwise this would crash

            # We are opening the ELG list so that we can check if we're including it in the stack
            try:
                elg = elg_list[i + 1] # because we need to exclude the header line
                elg = elg.split(" ")
                elg_name = elg[0]
                x_centroid = float(elg[1])
                y_centroid = float(elg[2])
            except:
                still_indexed = False
                print("You included extra images in your outfolder. Be careful")
            
            tempPath = "{}/{}".format(path, filename)

            if still_indexed: 
                condition = True
                if use_R200 == 1:
                    condition = self.is_within_r200(x_centroid, y_centroid)
                elif use_R200 == 2:
                    condition = not self.is_within_r200(x_centroid, y_centroid)
                else:
                    condition = self.is_within_range(elg_name, percentiles) # only include specific ELGs

                if condition:
                    image = import_fits(tempPath)
                    try:
                        images[i] = image
                        count += 1
                    except:
                        i -= 1 # it was a different kind of file. Skip to the next without skipping indeces

        return images, count
        
    def append_median_flux(self):
        '''Very situational. Loads in an elg list from Qing's code and adds the median flux for each elg. 
        Only needs to be run if the median flux is not written into the elg list file
        This will generate the median of the fluxes at the centroid based on the values of the continuum for the particular ELG

        Parameters:
            list_path: (String) path to the elg list
        '''

        elg_list = open(self.elg_list_path, mode="r")
        lines = elg_list.readlines()
        elg_list.close()

        printOut = lines[0][:-1] + " med_flux\n"

        for i in range(1, len(lines)):
            line = lines[i].split(" ")
            xCentroid = float(line[1])
            yCentroid = float(line[2])
            # we want to only use the continuum values
            redshift = float(line[self.z_column])
            wavn_array = self.continuum_range(redshift)
            median = self.sum_channels(wavn_array, xCentroid, yCentroid, algorithm="median")
            printOut = printOut + lines[i][:-1] + " {}\n".format(median)
        
        elg_list = open(self.elg_list_path, mode="w")
        elg_list.write(printOut)
        elg_list.close()

    def is_within_range(self, label, percentiles=(10,90)):
        '''Is used for stacking. Will determine if a given ELG is within the acceptable range to be used in stacking. Default range is 0-50 percentiles.
        
        Parameters:
            label: (String) the number of the ELG as provided by the elg_list

            percentiles: (tuple of floats) (Optional) determines what percentiles of brightness you want to use        
        Returns:
            (boolean) whether or not the elg should be included in stacking
        '''
        
        # print("def is_within_range is automatically returning TRUE. BE CAREFUL")
        # return True
        
        elg_list = open(self.elg_list_path, mode="r")
        lines = elg_list.readlines()
        elg_list.close()

        cutoff_lower = self.percentile_flux(percentiles[0])
        cutoff_upper = self.percentile_flux(percentiles[1])

        for line in lines:
            line = line.split(" ")
            if label == line[0]:
                if cutoff_lower <= float(line[self.med_flux_column]) and float(line[self.med_flux_column]) <= cutoff_upper:
                    return True
                else:
                    return False
        return False

    def percentile_flux(self, percentile):
        '''Determines the ELG which represents a certain percentile of their median fluxes

        Parameters:
            percentile: (float)
        
        Returns:
            (float) median of the flux medians
        '''

        elg_list = open(self.elg_list_path, mode="r")
        elg_list.readline()
        lines = elg_list.readlines()
        elg_list.close()

        values = []

        for i, line in enumerate(lines):
            line = line.split(" ")
            value = line[self.med_flux_column]
            value = value[:-1]
            values.append(float(value))
        
        return np.percentile(values, percentile)

    def create_stack(self, algorithm="mean", path=None, percentiles=(0, 100), return_length=False, use_R200=0):
        '''Stacks a series of images created by the create_image function

        Parameters:
            algorithm: (String) (Optional) The algorithm to use to create the images. default='mean'. Options: 'mean', 'sum', 'median', 'mode'
            path: (String) (Optional) Path to .fits folder. Defaults to None, which gives the objects output folder. Can be used to pull .fits files from anywhere
            percentiles: (tuple of floats) (Optional) determines what percentiles of brightness you want to use

        Returns:
            image: (2D array of floats) each point in the array represents a pixel in the image
        
        Exceptions:
            Will complain if you don't provide a valid algorithm
        '''

        self.write_file("stacking with {}, path:{}, percentiles:{}".format(algorithm, path, percentiles))

        images, length = self.load_images(path=path, percentiles=percentiles, use_R200=use_R200)  

        output = self.sum_arrays(images, algorithm=algorithm, stack=True)

        if return_length:
            return output, length
            
        return output

    def generate_stacks(self, algorithms, types, percentiles=(10, 90), name="", use_R200=0):
        '''Runner function for creating multiple stacks of algorithms and types. Will save all the results in images.
        To use this function, you already need to have images made (both PNGs and .fits)

        Parameters:
            algorithms: (list of Strings) choose among: 'mean', 'sum', 'median', 'mode'
            types: (list of Strings) choose among: 'continuum', 'halpha', 'nIIl' and 'nIIu'

            percentiles: (Optional) (tuple) defaults to (10, 90) the percentiles to include
            name: (Optional) (String) name to append the rest of the stack title to
        '''

        for imtype in types:
            for algorithm in algorithms:
                temp_name = name + "Stack of {} ELG {}, stacked by {}".format(self.name, imtype, algorithm)
                
                if use_R200 == 1:
                    temp_name = temp_name + " for ouside R200"
                elif use_R200 == 2:
                    temp_name = temp_name + " for within R200"

                self.write_file("Stacking algorithm type: {}, saved as {}".format(algorithm, temp_name))
                image = self.create_stack(algorithm=algorithm, path="{}/fits/{}".format(self.outPath,imtype), percentiles=percentiles, use_R200=use_R200)
                self.save_pdf(temp_name, image, stack=True, subPath=imtype)
                self.curve_of_growth(image, save=True, name=temp_name)

### Graphs ###
### ------ ###        

    def analyze_various_curves(self, algorithms, imtypes):
        '''Creates plots and drawings for analysis. Will be difficult to use, I'm working on it
        This is probably the worst code I have ever written
        '''

        buckets = [(10, 30), (30, 50), (50, 70), (70, 90)]
        
        overallVals = []
        overallCurve = np.zeros(APERTURE_SIZE)

        for imtype in imtypes:
            for algorithm in algorithms:
                plt.title("{} curves of {} stacked by {}".format(self.name, imtype, algorithm))
                for bucket in buckets:
                    image = self.create_stack(algorithm=algorithm, path="{}/fits/{}".format(self.outPath,imtype), percentiles=bucket)
                    curve = self.curve_of_growth(image, save=False)#name="Curve of growth of {} for {} stacked by {} percentiles {}".format(self.name, imtype, algorithm, bucket) ,save=True)
                    # curve = (xVals, curve, half_light, half_r, full_light, full_r)
                    overallVals = curve[0]
                    overallCurve += np.array(curve[1])
                    plt.plot(curve[0], curve[1], "--", label=bucket)

                plt.plot(overallVals, overallCurve, "-", color="black", label="Total")
                plt.legend()
                plt.xlabel("Radial Distance (pix)")
                plt.ylabel("Total Flux")
                plt.savefig("{}/{} curves of {} stacked by {}.png".format(self.outPath, self.name, imtype, algorithm))
                plt.clf()

                overallCurve = np.zeros(APERTURE_SIZE)
            
    def is_within_r200(self, x, y):
        '''Determines if a given x,y coordinate is within the r_200 of the cluster

        Parameters:
            x,y: (float) location of the galaxy

        Returns:
            (boolean)
        '''
        x_trans = x - self.data.shape[2]
        y_trans = y - self.data.shape[1]

        dist = ( (x_trans**2) + (y_trans**2) )**(1/2)

        return dist < self.r_200
    
    def append_within_r200(self):
        ''' Appends true or false for each ELG in the elg list if it's within the r200 radius of the cluster
        '''

        elg_list = open(self.elg_list_path, mode="r")
        lines = elg_list.readlines()
        elg_list.close()

        printOut = lines[0][:-1] + "withinR200\n"

        for i in range(1, len(lines)):
            line = lines[i].split(" ")
            xCentroid = float(line[1])
            yCentroid = float(line[2])

            value = self.is_within_r200(xCentroid, yCentroid)

            printOut = printOut + lines[i][:-1] + "{}\n".format(value)
        
        elg_list = open(self.elg_list_path, mode="w")
        elg_list.write(printOut)
        elg_list.close()
### Save PDF ###
### -------- ###

    def save_pdf(self, name, image, xLoc=SIZE, yLoc=SIZE, stack=False, subPath=None):
        '''creates a pdf using matplotlib's imshow() function

        Parameters:
            name: (string) name for file to be saved as
            image: (array of floats) 2 dimensional numpy array each containing a float representing colour make use of self.create_image

            stack: (Optional) (boolean) whether it is a stack or not. This gives it a special directory. defaults to False
            subPath: (Optional) (String) path from within the /pic or /fits tab to save them in. For subdirectories for more customization

        '''

        picsPath = self.outPath
        fitsPath = self.outPath
        if stack == False:
            picsPath += "/pic"
            fitsPath += "/fits"
            if subPath is not None:
                picsPath += "/{}".format(subPath)
                fitsPath += "/{}".format(subPath)
        else:
            picsPath = self.outPath + "/stacks"
            fitsPath = picsPath
            try:
                os.mkdir(self.outPath + "/stacks")
            except:
                print("There may have been a problem saving the stacks")

        norm = ImageNormalize(vmin=np.percentile(image, 5), vmax=np.percentile(image, 95), stretch=AsinhStretch(a=0.1))

        plt.rcParams["figure.figsize"] = [7.00, 3.50]
        plt.rcParams["figure.autolayout"] = True

        ax = plt.gca()
        ax.imshow(image, origin="lower", norm=norm)

        title = name.replace("halpha", "hα")
        ax.set_title(title)

        if stack == False:
            xLocs, xLabels = plt.xticks()
            yLocs, yLabels = plt.yticks()
            xLabels = np.linspace(xLoc - SIZE, xLoc + SIZE, num=len(xLocs), dtype=int)
            yLabels = np.linspace(yLoc - SIZE, yLoc + SIZE, num=len(yLocs), dtype=int)

            ax.set_xticklabels(xLabels)
            ax.set_yticklabels(yLabels)

            ax.set_xlabel("x (pix)")
            ax.set_ylabel("y (pix)")
        else:
            plt.axis('off')

        plt.savefig("{}/{}.png".format(picsPath, name))
        fits.writeto("{}/{}".format(fitsPath, name + ".fits"), image, overwrite=True)
        plt.clf()

### CURVES OF GROWTH ###
### ---------------- ###

    def generate_distance_array(self, size, mode="center"):
        '''Generates a two dimensional array where each entry is that cell's distance from the center of the array. Used for curve of growth

        Parameters:
            size: (int) Must be even, image must be square
        Returns:
            distances: (2D array of floats)
        
        Ok so how this works is really goofy. Imagine a square grid with even length.
        We take the center as the center crosshair, and then we're calculating the distance to the center of each cell in the grid.
        To do this, we simply calculate how far away in X and Y that cell is, then use pythagoras.
        One problem: we're using the variable size/2 to denote the center, but since there will inevitably be an entry at size/2, we would have a distance of 0.
        To solve this, we artificially increase the x and y locations by 1 if they are greater than or equal to size/2.
        If size/2=30, then on the left will be x=29 and on the right x=31. This is the first way I thought to make it work. It's goofy, I know.
        '''

        distances = np.zeros((size, size))

        for i in range(size):
            for j in range(size):
                tempX = i
                tempY = j

                if i >= size/2:
                    tempX += 1
                if j >= size/2:
                    tempY += 1

                xTrans = abs(tempX - size/2)
                yTrans = abs(tempY - size/2)

                distance = np.sqrt(xTrans**2 + yTrans**2)
                distances[i, j] = distance

        return distances

    def curve_of_growth(self, image, save=True, name=""):
        '''This function generates a curve of growth based on taking the distance to the center of each pixel and increasing outwards

        Parameters:
            image: (2D array of floats) the input image. Must have side lengths 2*SIZE

            save: (Optional) (boolean) if you want to save the images or not. Defaults to True
            name: (Optional) (String) name to save the image as, if you're saving it

        Returns:
            TBD
        '''

        savePath = self.outPath + "/curves"
        try:
            os.mkdir(savePath)
        except:
            go = True

        distances = self.dist_array

        curve = []

        for p in range(APERTURE_SIZE): # each pixel length outwards
            curve.append(0)
            for i in range(2*SIZE): # These two loops go through the distance array to check
                for j in range(2*SIZE):
                    if distances[i, j] <= p:
                        curve[p] += image[i, j]
        
        xVals = np.arange(1, APERTURE_SIZE + 1)

        # I want to make a horizontal line where we are at 50% flux
        full_light = self.determine_full_light(curve)
        
        half_light = full_light/2

        half_r = self.determine_radius(xVals, curve, half_light)
        full_r = self.determine_radius(xVals, curve, full_light)

        if save:
            plt.axhline(half_light, label="half flux: {:.3f}".format(half_light), color="red", lw=0.5)
            plt.axvline(x=half_r, color="red", lw=0.5)

            plt.axhline(full_light, label="full flux: {:.3f}".format(full_light), color="green", lw=0.5)
            plt.axvline(x=full_r, color="green", lw=0.5)

            plt.plot(xVals, curve, "--")
            title = name.replace("halpha", "hα")

            plt.title(title)
            plt.ylabel("Total Flux")
            plt.xlabel("Distance from center (Pix)")
            plt.legend()
            plt.savefig(savePath + "/CUSTOM {}.png".format(name))
            plt.clf()
            
            self.draw_apertures(name, image, [half_r, full_r])

        return (xVals, curve, half_light, half_r, full_light, full_r)
    
    def determine_radius(self, radius_array, flux_array, target_flux):
        '''Determines the approximate radius of a given flux generated by curve_of_growth

        Parameters:
            radius_array: (list of ints, or floats I suppose)
            flux_array: (list of floats)
            target_flux: (float)
        
        Returns:
            target_r: (float)
        '''

        upperIndex = 0
        lowerIndex = 0

        # determine the two fluxes that the target flux is between, get their corresponding indeces
        for i, val in enumerate(flux_array):
            if val >= target_flux:
                upperIndex = i
                lowerIndex = i - 1
                break
        
        # determine how 'far' from the lowerFlux to the upperFlux the target flux is
        upperDistance = flux_array[upperIndex] - target_flux
        lowerDistance = target_flux - flux_array[lowerIndex]

        totalDistance = lowerDistance + upperDistance

        distance = lowerDistance / totalDistance

        # use that ratio to determine how 'far' away the target radius should be from the lower one
        r_totalDistance = radius_array[upperIndex] - radius_array[lowerIndex]

        r_lowerDistance = distance * r_totalDistance

        target_r = r_lowerDistance + radius_array[lowerIndex]

        return target_r

    def draw_apertures(self, name, image, radii):
        '''Draws any number of circles on an imshow() image with given radii

        Parameters:
            name: (String) Name to save the image as
            image: (2D array of floats) image to use in imshow()
            radius: (list of floats)
        '''
        norm = ImageNormalize(vmin=np.min(image), vmax=np.max(image), stretch=AsinhStretch(a=0.1))

        savePath = self.outPath + "/curves"

        plt.rcParams["figure.figsize"] = [7.00, 3.50]
        plt.rcParams["figure.autolayout"] = True

        ax = plt.gca()

        ax.imshow(image, origin="lower", norm=norm)

        title = name.replace("halpha", "hα")
        ax.set_title(title)

        plt.axis('off')

        for i, radius in enumerate(radii):
            circ = Circle((SIZE + 0.5, SIZE + 0.5), radius, color='red', linewidth=1, fill=False)
            ax.add_patch(circ)

            theta = i * (np.pi / 4) # increment by 30degrees for each radii

            # plot a radial line and text
            x = [SIZE + 0.5, SIZE + 0.5 + (radius * np.cos(theta))]
            y = [SIZE + 0.5, SIZE + 0.5 + (radius * np.sin(theta))]
            plt.plot(x, y, color='red', linewidth=0.5)

            size = self.determine_length_pix(radius)
            plt.text(SIZE + 1 + (radius * np.cos(theta)), SIZE + 1 + (radius * np.sin(theta)), "r={:.2f}kpc".format(size.value), color='black', size=12)

        plt.savefig("{}/{}.png".format(savePath, name))
        plt.clf()

    def determine_length_pix(self, length):
        '''Determines the size of an object at the redshift of the galaxy cluster

        d = size / angle
        d can be determined by the redshift and geometry of the universe using astropy.cosmology

        Parameters:
            length: (float) length of the object in pixels

        Returns:
            size: (float) size of that length in kpc
        '''

        universe = FlatLambdaCDM(H0=70, Om0=0.3)

        angular_distance = universe.angular_diameter_distance(self.redshift) # Mpc / rad

        angular_distance = angular_distance * 1000 # kpc / rad

        angular_distance = angular_distance / (180 / np.pi) / 3600 # kpc / arcsec

        angular_size = length * RESOLUTION # arcsec

        size = angular_distance * angular_size # kpc

        return size

    def determine_length_kpc(self, size):
        '''Determines the size of an object, in pixels at the redshift of the galaxy cluster, for a given distance in kpc

        d = size / angle
        d can be determined by the redshift and geometry of the universe using astropy.cosmology

        Parameters:
            length: (float) length of the object in pixels

        Returns:
            size: (float) size of that length in kpc
        '''

        universe = FlatLambdaCDM(H0=70, Om0=0.3)

        angular_distance = universe.angular_diameter_distance(self.redshift) # Mpc / rad

        angular_distance = angular_distance * 1000 # kpc / rad

        angular_distance = angular_distance / (180 / np.pi) / 3600 # kpc / arcsec

        angular_size = size / angular_distance

        length = angular_size / RESOLUTION

        return length.value

    def determine_full_light(self, curve):
        '''This function takes a curve of growth and determines the flux of full light
        The way in which this is done is it takes each point, and determines if the average of each point on either side is 'close' to that point. 
        The 'closeness' required is determined by a constant CURVE_CLOSENESS. The list of all these points should approximate the points in the asymptote
        The median of these points is then taken. This is the full light flux. It will then be attributed a Radius based on another function
        In this way, it will be the first radius in which the full light flux is observed

        If the maximum value is far larger than this cutoff point, then the maximum point will be chosen
        Parameters:
            curve: (list of floats)
        
        Returns:
            max_flux: (float)
        '''

        curve_radii = []
        acceptable_points = []
        acceptable_radii = []

        for i, flux in enumerate(curve):
            curve_radii.append(i)
            if i != 0 and i != len(curve) - 1: # don't want to include the edge values
                avg = (curve[i - 1] + curve[i + 1]) / 2 # the average of the neighbouring points

                if abs(avg - flux) < (CURVE_CLOSENESS * flux): # is it close?
                    acceptable_points.append(flux) # oh yes
                    acceptable_radii.append(i)
        
        max_flux = np.median(acceptable_points)
        
        if max(curve) / max_flux > FULL_LIGHT_CUTOFF:
            max_flux = max(curve)
        # plt.plot(curve_radii, curve, color="blue")
        # plt.plot(acceptable_radii, acceptable_points, color="red")
        # plt.axhline(max_flux)
        # plt.axvline(self.determine_radius(curve_radii, curve, max_flux))
        # plt.show()

        return max_flux

    def compare_curves(self, name, curve1, curve2):
        '''Superimposes multiple curves

        Parameters:
            name: (String) Name to save the image as
            curve1/curve2: (tuple: (xVals, yVals))
        '''
        
        plt.plot(curve1[0], curve1[1], "--")
        plt.plot(curve2[0], curve2[1], "--")
        plt.title("{}".format(name))
        plt.ylabel("Total Flux")
        plt.xlabel("Distance from center (Pix)")
        plt.legend()
        plt.grid('on')
        plt.savefig(self.outPath + "/CUSTOM {}.png".format(name))
        plt.clf()

### ORIENTATION ###
### ----------- ###

    def determine_angle(self, xCoord, yCoord, shape):
        '''Determines the angle of an ELG in the cube, from the center, based on the angle from the 

        Parameters:
            xCoord: (float) x position, in pixels
            yCoord: (float) y position, in pixels
        
        Returns:
            theta: (float) Angle in radians
        '''

        xCenter = shape[0]
        yCenter = shape[1]

        dx = xCoord - xCenter
        dy = yCoord - yCenter

        theta = np.arctan2(dy, dx)

        return abs(theta) #For whatever reason, these are all coming out to be negative from the way I want them to be measured.

        # plt.imshow(self.data[30])
        # x = [xCenter, xCoord]
        # y = [yCenter, yCoord]
        # plt.plot(x, y, color='red', linewidth=0.5)
        # x = [xCenter, xCenter*2 - 1]
        # y = [yCenter, yCenter]
        # plt.plot(x, y, color='red', linewidth=0.5)
        # plt.text(xCenter, yCenter + 10, "θ = {:.2f}".format(theta), color='black', size=12)
        # plt.show()

    def translate_point(self, xLoc, yLoc, d_theta, size):
        ''' Rotates a given x and y location by a given angle (in radians), outputs new xVal, yVal
        '''

        xCenter = size/2 - 1
        yCenter = size/2 - 1
        radius = np.sqrt( (xCenter - xLoc)**2 + (yCenter - yLoc)**2 )

        theta_i = self.determine_angle(xLoc, yLoc, (xCenter, yCenter))
        theta_f = theta_i + d_theta

        xVal = xCenter + (radius * np.cos(theta_f))
        yVal = yCenter + (radius * np.sin(theta_f))

        return xVal, yVal

    def rotate(self, image, d_theta):
        '''
        '''

        new_image = np.zeros(image.shape)
        size = image.shape[0]
        for i in range(size):
            for j in range(size):
                xVal, yVal = self.translate_point(i, j, d_theta, size)
                xVal = int(xVal)
                yVal = int(yVal)
                if xVal < size and xVal >= 0 and size > yVal and yVal >= 0:
                    new_image[xVal, yVal] = image[i, j]
        
        norm = ImageNormalize(vmin=np.min(image), vmax=np.max(image), stretch=AsinhStretch(a=0.1))

        plt.rcParams["figure.figsize"] = [7.00, 3.50]
        plt.rcParams["figure.autolayout"] = True

        ax = plt.gca()

        ax.imshow(new_image)

        plt.show()
        plt.clf()

    def run_determine_angle(self):
        elg_list = np.loadtxt(self.elg_list_path, skiprows=1)

        for elg in elg_list:
            self.determine_angle(int(elg[1]), int(elg[2]))
    
    def run_rotate(self, path):
        image = import_fits(path)

        thetas = np.arange(0, 360, 30)
        for theta in thetas:
            self.rotate(image, np.radians(theta))

# For fun and testing functions. Can be ignored            
    def compare(self, image_1, image_2):
        '''compares two images and returns an image with either 0 or 1 based on which image has the higher value there

        Parameters:
            image_1, image_2: (2D array of floats) the input image arrays
        Returns:
            image: (2D array of floats) the resulting image
        '''
        image = np.zeros((len(image_1[0]), len(image_1[0])))

        for i in range(len(image_1[0])):
            for j in range(len(image_1[0])):
                if image_1[i][j] < image_2[i][j]:
                    image[i][j] = 1
        
        return image

    def graph(self, xCentroid, yCentroid):
        '''
        '''

        size = 0
        yVals = []

        for i in range(len(self.data)):
            yVals.append(self.data[i, yCentroid, xCentroid])
            size = i

        xVals = np.linspace(1, len(self.data), num=size + 1)

        plt.scatter(xVals, yVals - np.median(yVals))
        plt.axhline(np.median(yVals))
        plt.show()
        plt.clf()
    
    def graph_wavn(self, name, continuum, emission, xCentroid, yCentroid):
        '''
        '''

        yContinuum = []
        yEmission = []
        yTotal = []

        for wavn in continuum:
            channel = self.get_channel(wavn)
            yContinuum.append(self.data[channel, yCentroid, xCentroid])

        for wavn in emission:
            channel = self.get_channel(wavn)
            yEmission.append(self.data[channel, yCentroid, xCentroid])

        total = self.get_wavenumber_array()

        for wavn in total:
            channel = self.get_channel(wavn)
            yTotal.append(self.data[channel, yCentroid, xCentroid])

        plt.plot(total, yTotal, "--")
        plt.plot(emission, yEmission, color="red")
        plt.plot(continuum, yContinuum, color="blue")
        plt.axhline(y=0, color="black")
        plt.title(name)
        plt.show()
        plt.clf()
